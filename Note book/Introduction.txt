D3D中的实体：着色器、纹理、状态、......这些物体的parent都是Device；

Device
	|-SwapChain		// 交换链
	|		|-FrontBuffer(Texture)		// 前缓冲区（扫描缓冲区，发送给显示器显示的，自动生成的，不用负责）
	|		|-BackBuffer(Texture)		// 后缓冲区（实际绘制的缓冲区）
	|			|-RenderTargetView		// 渲染目标视图，将其绑定到渲染管线上，承担所有的绘制工作
	|
	|-Buffer		// 顶点缓存
	|	|-View
	|
	|-Shader		//  着色器
	|
	|-Texture		// 纹理资源
	|	|-view		// 资源视图：用于将资源间接绑定到着色器管道
	|
	|-State			// 渲染管线的状态
	|
	|-Context		// 上下文

Device：图形适配器，逻辑显卡；可以被具有硬件驱动程序的实际物理接口支持，我们使用Device对象来创建我们渲染时需要的对象以及分配资源，用于创建、分配
Context：上下文，可用于发出渲染命令，并配置渲染管道，以及查询驱动程序Driver信息，用于绘制
即时上下文和延迟上下文：区别是即时上下文是组建Command命令列表并Exec，而延迟上下文只组件Command命令列表，再通知即时上下文执行，延迟上下文不能查询驱动程序


DXGI：最底层的工作，可以从D3D中剥离出去的任务，遍历设备上所有的Device，显示渲染帧，控制Gamma值；可用Device对象创建交换链，把渲染好的帧缓冲区发送到输出那里

传统的光栅化：在显卡有一块缓存，其中的帧缓存包含了显示器所需要显示的一帧图像的所有信息，图形适配器(Device)逐行扫描像素，将其转换为某种格式比如HDMI，发送给显示器，然后显示器将他们逐行写入。
单缓冲区：如果只有一个缓冲区的话，边写边发送给显示器，如果扫描了一半，然后你再去缓冲区的上半部分绘制图形，那显示器上就不会显示了，因为扫描永远只能往下走，这样肯定是不行的，因此就有了双缓冲区。
双缓冲区：前缓冲去和后缓冲区；
前缓冲区：前缓冲区的内容正在被扫描到要显示的显示器上； 它只保存了已经绘制完成的画面，不能被写入，非常稳定，会一直被扫描
后缓冲区：是我们真正在绘制的地方
Present：将后缓冲区非常快的复制到前缓冲区
Flip：本质和重命名一样，将前后缓冲区名字互换。 取决于硬件和设置
撕裂：前缓冲区被扫描了一半，此时被Flip，那么显示器此时就会显示Flip之前的上一半，和Flip之后的下一半。 解决办法就是必须在扫描完一帧后才能Flip；
跳帧：绘制一帧的时间比扫描一帧的时间更长，解决办法：再添加一个缓冲区在一定程度上可以缓解。（三重缓冲）但是这样会让延迟加大。
缓冲区也是一种纹理，可以在该纹理上调用函数创建RenderTargetView并渲染；


初始化步骤：
1、创建Device，SwapChain，Context； 需要注意的是SwapChainDesc中需要指定的BackBuffer数量以及用途
2、SwapChain->Present(1, 0);	// 交换前后缓冲区，以便于能看到画面，第一个参数是间隔时间，1代表60帧，2代表30帧；第二个参数Flag需要看MSDN，默认0；
3、创建RenderTargetView：SwapChain得到BackBuffer，根据BackBuffer由Device创建RenderTargetView，拿完View之后记得把获取的BackBuffer释放掉
4、拿到RenderTargetView之后，就可以开始在View上绘制了，其中clearRenderTargetView可以清空绘制区域并附上颜色(MSDN解释：将渲染目标中的所有元素设置为一个值。)